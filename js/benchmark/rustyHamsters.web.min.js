!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.hamsters=t():e.hamsters=t()}(this,(()=>(()=>{"use strict";var __webpack_modules__={327:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{A:()=>__WEBPACK_DEFAULT_EXPORT__});class Legacy{constructor(hamsters){this.hamsters=hamsters,this.scaffold=(params,resolve,reject)=>{var rtn={data:[],dataType:void 0!==params.dataType?params.dataType:null};this.hamsters.habitat.reactNative&&(self.rtn=rtn),this.hamsters.habitat.node||this.hamsters.habitat.isIE?eval(params.hamstersJob):params.hamstersJob(),resolve(rtn.data)}}}const __WEBPACK_DEFAULT_EXPORT__=Legacy},386:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{A:()=>__WEBPACK_DEFAULT_EXPORT__});class Regular{constructor(){this.scaffold=function(){function handleDataType(e){return this.params.sharedArray||this.params.dataType&&(e.data=typedArrayFromBuffer(e.dataType,e.data)),getTransferableObjects(e)}function typedArrayFromBuffer(e,t){const r={Uint32:Uint32Array,Uint16:Uint16Array,Uint8:Uint8Array,Uint8clamped:Uint8ClampedArray,Int32:Int32Array,Int16:Int16Array,Int8:Int8Array,Float32:Float32Array,Float64:Float64Array};return r[e]?new r[e](t):t}function returnResponse(e,t){t&&t.length>0?postMessage(e,t):postMessage(e)}function getTransferableObjects(e){const t=new Set,r=["Int32Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Uint32Array","Float32Array","Float64Array"],s="undefined"!=typeof self?self:window,a=[...r,"ArrayBuffer","MessagePort","ImageBitmap","OffscreenCanvas"];for(const i in e)if(e.hasOwnProperty(i))for(const n of a)void 0!==s[n]&&e[i]instanceof s[n]&&(r.includes(n)?t.add(e[i].buffer):t.add(e[i]));return Array.from(t)}self.params={},self.rtn={},self.onmessage=function(message){this.params=message.data,this.rtn={data:[],dataType:void 0!==this.params.dataType?this.params.dataType:null,index:this.params.index},this.params.sharedBuffer&&(this.params.sharedArray=typedArrayFromBuffer(this.params.dataType,this.params.sharedBuffer)),eval(this.params.hamstersJob);const buffers=handleDataType(this.rtn);returnResponse(this.rtn,buffers)}.bind(this)}}}const __WEBPACK_DEFAULT_EXPORT__=Regular},817:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{A:()=>__WEBPACK_DEFAULT_EXPORT__});class Shared{constructor(){this.scaffold=function(){self.params={},self.rtn={},addEventListener("connect",(incomingConnection=>{var port=incomingConnection.ports[0];port.start(),port.addEventListener("message",(incomingMessage=>{this.params=incomingMessage.data,this.rtn={data:[],dataType:this.params.dataType},eval("("+this.params.hamstersJob+")")(),port.postMessage(this.rtn)}),!1)}),!1)}}}const __WEBPACK_DEFAULT_EXPORT__=Shared}},__webpack_module_cache__={};function __webpack_require__(e){var t=__webpack_module_cache__[e];if(void 0!==t)return t.exports;var r=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](r,r.exports,__webpack_require__),r.exports}__webpack_require__.d=(e,t)=>{for(var r in t)__webpack_require__.o(t,r)&&!__webpack_require__.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),__webpack_require__.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);var __webpack_exports__={};__webpack_require__.d(__webpack_exports__,{default:()=>rustyHamsters});class Habitat{constructor(e){this.hamsters=e,this.debug=!1,this.importScripts=null,this.relay=null,this.memoize=!1,this.persistence=!0,this.browser=this.isBrowser(),this.webWorker=this.isWebWorker(),this.node=this.isNode(),this.reactNative=this.isReactNative(),this.shell=this.isShell(),this.transferable=this.supportsTransferableObjects(),this.atomics=this.supportsAtomicOperations(),this.proxies=this.supportsProxies(),this.isIE=this.isInternetExplorer(),this.selectHamsterWheel=this.selectHamsterWheel.bind(this),this.sharedWorker=this.locateSharedWorkerObject(),this.locateBlobBuilder=this.findAvailableBlobBuilder(),this.legacy=this.isLegacyEnvironment(),this.Worker=this.locateWorkerObject(),this.maxThreads=this.determineGlobalThreads(),this.keys=this.getHabitatKeys()}determineGlobalThreads(){let e=4;return this.browser&&void 0!==navigator.hardwareConcurrency&&(e=navigator.hardwareConcurrency,this.isFirefox()&&(e=e>20?20:e)),this.node&&"undefined"!=typeof os&&(e=os.cpus().length),e}isFirefox(){return"undefined"!=typeof navigator&&void 0!==navigator.userAgent&&-1!==navigator.userAgent.toLowerCase().indexOf("firefox")}locateWorkerObject(){return"undefined"!=typeof Worker&&Worker}locateSharedWorkerObject(){return"undefined"!=typeof SharedWorker&&SharedWorker}isBrowser(){return"object"==typeof window}isInternetExplorer(){return"undefined"!=typeof navigator&&void 0!==navigator.userAgent&&(-1!==navigator.userAgent.indexOf("MSIE ")||-1!==navigator.userAgent.indexOf("Trident/"))}isNode(){return"object"==typeof process&&!this.isWebWorker()&&!this.browser}isWebWorker(){return"function"==typeof importScripts&&!this.isReactNative()}isReactNative(){return"undefined"!=typeof navigator&&void 0!==navigator.product&&"ReactNative"===navigator.product}isShell(){return"undefined"==typeof navigator&&!this.isNode()&&!this.isWebWorker()&&!this.isReactNative()}isLegacyEnvironment(){let e=!this.Worker;return this.isWebWorker()&&void 0!==this.SharedWorker&&(e=!this.supportsSharedWorkers()),e}supportsSharedWorkers(){let e=!1;try{let t=this.generateWorkerBlob(this.selectHamsterWheel());new this.SharedWorker(t,"SharedHamsterWheel"),e=!0}catch(t){e=!1}return e}findAvailableBlobBuilder(){return"undefined"!=typeof BlobBuilder?BlobBuilder:"undefined"!=typeof WebKitBlobBuilder?WebKitBlobBuilder:"undefined"!=typeof MozBlobBuilder?MozBlobBuilder:"undefined"!=typeof MSBlobBuilder?MSBlobBuilder:"Environment does not support data blobs!"}createDataBlob(e){if("undefined"==typeof Blob){let t=new(this.locateBlobBuilder());return t.append([e],{type:"application/javascript"}),t.getBlob()}return new Blob([e],{type:"application/javascript"})}generateWorkerBlob(e){return URL.createObjectURL(this.createDataBlob(`(${e.toString()})();`))}supportsTransferableObjects(){return"undefined"!=typeof Uint8Array}supportsAtomicOperations(){return"undefined"!=typeof SharedArrayBuffer}supportsProxies(){return"undefined"!=typeof Proxy}selectHamsterWheel(){return this.isIE?this.hamsters.scaffold.legacy.scaffold:this.reactNative?"reactNativeHamster.js":this.node?"./node_modules/hamsters.js/build/common/node.js":this.generateWorkerBlob(this.hamsters.scaffold.regular.scaffold)}getHabitatKeys(){return["worker","sharedworker","legacy","proxies","reactnative","atomics","transferable","browser","shell","node","debug","persistence","importscripts","maxthreads","parentport","webworker","relay"]}}const habitat=Habitat;class Pool{constructor(e){this.hamsters=e,this.threads=[],this.running=[],this.pending=[],this.fetchHamster=this.getAvailableThread.bind(this)}addWorkToPending(e,t,r,s,a){this.hamsters.habitat.debug&&(r.scheduler.metrics.threads[r.scheduler.count].enqueued_at=Date.now()),this.pending.push({index:e,hamsterFood:t,task:r,resolve:s,reject:a})}processQueuedItem(e,t){return this.hamsters.habitat.debug&&(t.task.scheduler.metrics.threads[t.index.id].dequeued_at=Date.now()),this.runTask(e,t.index,t.hamsterFood,t.task,t.resolve,t.reject)}getAvailableThread(e){return this.hamsters.habitat.persistence?this.threads[e]:this.spawnHamster()}keepTrackOfThread(e,t){this.hamsters.habitat.debug&&(e.scheduler.metrics.threads[t].started_at=Date.now()),e.scheduler.workers.push(t),this.running.push(t)}spawnHamsters(e){for(;e--;)this.threads.push(this.spawnHamster())}spawnHamster(){const{selectHamsterWheel:e,SharedWorker:t,Worker:r}=this.hamsters.habitat,s=e();return this.hamsters.habitat.webWorker?new t(s,"SharedHamsterWheel"):new r(s)}prepareMeal(e,t,r){e.id=t;const s={array:r.input.array&&0!==r.input.array.length?this.hamsters.data.getSubArrayFromIndex(e,r.input.array):[],index:e};void 0!==r.scheduler.sharedBuffer&&(s.sharedBuffer=r.scheduler.sharedBuffer);const a=new Set(["array","threads","sharedArray"]);for(const e in r.input)r.input.hasOwnProperty(e)&&!a.has(e)&&(s[e]=r.input[e]);return s}runTask(e,t,r,s,a,i){const n=this.running.length;this.hamsters.pool.keepTrackOfThread(s,n),this.hamsters.habitat.legacy?this.hamsters.scaffold.legacy.scaffold(r,a,i):(this.hamsters.pool.trainHamster(t,s,n,e,a,i),this.hamsters.data.feedHamster(e,r)),s.scheduler.count+=1}hamsterWheel(e,t,r,s,a){const i=this.prepareMeal(e,t,r);if(this.hamsters.habitat.maxThreads<=this.running.length)this.addWorkToPending(e,i,r,s,a);else{const t=this.fetchHamster(this.running.length);this.runTask(t,e,i,r,s,a)}}returnOutputAndRemoveTask(e,t){e.scheduler.sharedBuffer&&(e.output=hamsters.data.processDataType(e.input.dataType,e.scheduler.sharedBuffer)),e.input.aggregate&&(e.output=this.hamsters.data.aggregateThreadOutputs(e.output,e.input.dataType)),e.input.sort&&(e.output=this.hamsters.data.sortOutput(e.output,e.input.sort)),this.hamsters.habitat.debug&&(e.scheduler.metrics.completed_at=Date.now(),console.info("Hamsters.js Task Completed: ",e)),t(e.output)}removeFromRunning(e,t){this.running.splice(this.running.indexOf(t),1),e.scheduler.workers.splice(e.scheduler.workers.indexOf(t),1)}processReturn(e,t,r){const s=this.hamsters.habitat.reactNative,a=this.hamsters.habitat.node,i=t.data,n=s?JSON.parse(t).data:void 0!==i.data?i.data:i,o=a?t.index.id:i.index.id;1!==r.scheduler.threads?s||r.input.mixedOutput?r.output[o]=n:this.hamsters.data.addThreadOutputWithIndex(r,e,n):r.output=n}setOnMessage(e,t,r){this.hamsters.habitat.webWorker?(e.port.onmessage=t,e.port.onmessageerror=r,e.port.onerror=r):this.hamsters.habitat.node?(e.once("message",t),e.once("onmessageerror",r),e.once("error",r)):(e.onmessage=t,e.onmessageerror=r,e.onerror=r)}trainHamster(e,t,r,s,a,i){this.hamsters.pool.setOnMessage(s,(i=>{if(this.hamsters.pool.processReturn(e,i,t),this.hamsters.habitat.debug&&(t.scheduler.metrics.threads[r].completed_at=Date.now()),this.hamsters.pool.removeFromRunning(t,r),0===t.scheduler.workers.length&&t.scheduler.count===t.scheduler.threads&&this.hamsters.pool.returnOutputAndRemoveTask(t,a),this.hamsters.habitat.persistence||s.terminate(),0!==this.hamsters.pool.pending.length){const e=this.hamsters.pool.fetchHamster(this.hamsters.pool.running.length);this.hamsters.pool.processQueuedItem(e,this.hamsters.pool.pending.shift())}}),i)}scheduleTask(e){let t=0;return new Promise(((r,s)=>{for(this.hamsters.debug&&(e.scheduler.metrics.started_at=Date.now());t<e.scheduler.threads;)this.hamsterWheel(e.scheduler.indexes[t],t,e,r,s),t+=1}))}}const pool=Pool;class Data{constructor(e){this.hamsters=e,this.getSubArrayFromIndex=this.getSubArrayUsingIndex.bind(this),this.getSubArrayIndexes=this.calculateIndexes.bind(this),this.sortOutput=this.sortTaskOutput.bind(this),this.aggregateThreadOutputs=this.aggregateThreadOutputs.bind(this),this.processDataType=this.typedArrayFromBuffer,this.prepareFunction=this.prepareWorkerTask.bind(this),this.feedHamster=this.messageWorkerThread.bind(this),this.getBufferSize=this.getBufferSize,this.createSharedBuffer=this.createSharedBuffer.bind(this),this.getDataType=this.getDataType,this.setupSharedArrayBuffer=this.setupSharedArrayBuffer.bind(this)}messageWorkerThread(e,t){return this.hamsters.habitat.reactNative?e.postMessage(JSON.stringify(t)):this.hamsters.habitat.webWorker?e.port.postMessage(t):e.postMessage(t,this.hamsters.data.getTransferableObjects(t))}getTransferableObjects(e){const t=[],r=[],s=["Int32Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Uint32Array","Float32Array","Float64Array"],a=["ArrayBuffer","MessagePort","ImageBitmap","OffscreenCanvas"],i="undefined"!=typeof window?window:__webpack_require__.g;for(const n in e){for(const r of s)if(void 0!==i[r]&&e[n]instanceof i[r]){t.push(e[n].buffer);break}for(const t of a)if(void 0!==i[t]&&e[n]instanceof i[t]){r.push(e[n]);break}}return t.concat(r)}typedArrayFromBuffer(e,t){const r={Uint32:Uint32Array,Uint16:Uint16Array,Uint8:Uint8Array,Uint8clamped:Uint8ClampedArray,Int32:Int32Array,Int16:Int16Array,Int8:Int8Array,Float32:Float32Array,Float64:Float64Array};return r[e]?new r[e](t):t}prepareWorkerTask(e){let t=String(e);return t.substring(t.indexOf("{")+1,t.length-1)}sortTaskOutput(e,t){switch(t){case"desc":case"asc":return Array.prototype.sort.call(e,(function(e,r){return"asc"===t?e-r:r-e}));case"ascAlpha":return e.sort();case"descAlpha":return e.reverse();default:return e}}getBufferSize(e){return e.byteLength}createSharedBuffer(e){const t=this.getBufferSize(e),r=new SharedArrayBuffer(t);return new e.constructor(r).set(e),r}setupSharedArrayBuffer(e){return this.createSharedBuffer(e)}aggregateThreadOutputs(e,t){if(!t)return e.reduce((function(e,t){return e.concat(t)}));let r=0,s=e.length,a=0;for(;r<s;r+=1)a+=e[r].length;let i=this.processDataType(t,a),n=0;for(r=0;r<s;r+=1)i.set(e[r],n),n+=e[r].length;return i}addThreadOutputWithIndex(e,t,r){let s=0;const a=r.length;for(;s<a;s++)e.output[t.start+s]=r[s]}calculateIndexes(e,t){if(1===t)return[{start:0,end:e.length-1}];const r=[],s=Math.floor(e.length/t);let a=0;for(let e=0;e<t;e++){const e=a+s-1;r.push({start:a,end:e}),a=e+1}return a<e.length&&(r[t-1].end=e.length-1),r}getSubArrayUsingIndex(e,t){return t.slice(e.start,e.end+1)}}const data=Data;class Task{constructor(e,t,r){this.input=t,this.output=[],this.scheduler={count:0,threads:t.threads||1,workers:[]},e.habitat.legacy?this.setupLegacyTask(e,r):this.setupModernTask(e,t,r),e.habitat.debug&&this.setupDebugMetrics()}setupLegacyTask(e,t){this.scheduler.threads=1,e.habitat.node||e.habitat.isIE||(this.input.hamstersJob=t)}setupModernTask(e,t,r){this.input.hamstersJob=e.habitat.legacy?r:e.data.prepareFunction(r),t.sharedArray&&e.habitat.atomics?(this.scheduler.indexes=t.indexes||e.data.getSubArrayIndexes(t.sharedArray,this.scheduler.threads),this.scheduler.sharedBuffer=e.data.setupSharedArrayBuffer(t.sharedArray),this.input.sharedArray=[]):this.scheduler.indexes=t.indexes||e.data.getSubArrayIndexes(t.array,this.scheduler.threads)}setupDebugMetrics(){this.scheduler.metrics={created_at:Date.now(),started_at:null,completed_at:null,threads:this.setupThreadMetrics()}}setupThreadMetrics(){let e=0,t=[];for(;e<this.scheduler.threads;)t.push({created_at:Date.now(),started_at:null,enqueued_at:null,dequeued_at:null,completed_at:null}),e+=1;return t}}const task=Task;var legacy=__webpack_require__(327),regular=__webpack_require__(386),shared=__webpack_require__(817);class NodeStore{constructor(e){this.maxSize=e,this.cache=new Map}get(e){if(this.cache.has(e)){const t=this.cache.get(e);return this.cache.delete(e),this.cache.set(e,t),Promise.resolve(t)}return Promise.resolve(null)}set(e,t){if(this.cache.size>=this.maxSize){const e=this.cache.keys().next().value;this.cache.delete(e)}return this.cache.set(e,t),Promise.resolve()}clear(){return this.cache.clear(),Promise.resolve()}}const stores_NodeStore=NodeStore;class WebStore{constructor(e,t,r){this.dbName=e,this.storeName=t,this.maxSize=r,this.db=null,this.initDB()}initDB(){const e=this,t=indexedDB.open(this.dbName,1);t.onerror=function(e){console.error("Error opening database:",e.target.error)},t.onupgradeneeded=function(t){const r=t.target.result;if(!r.objectStoreNames.contains(e.storeName)){const t=r.createObjectStore(e.storeName,{keyPath:"key"});t.createIndex("by_key","key",{unique:!0}),t.createIndex("by_timestamp","timestamp")}},t.onsuccess=function(t){e.db=t.target.result}}get(e){const t=this;return new Promise((function(r,s){if(!t.db)return console.error("Database not initialized"),void r(null);const a=t.db.transaction([t.storeName],"readonly").objectStore(t.storeName).get(e);a.onsuccess=function(a){const i=a.target.result;i?t.updateTimestamp(e).then((()=>r(i.value))).catch(s):r(null)},a.onerror=function(e){s(e.target.error)}}))}set(e,t){const r=this;return new Promise((function(s,a){if(!r.db)return console.error("Database not initialized"),void s();r.checkSize().then((()=>{const i=r.db.transaction([r.storeName],"readwrite").objectStore(r.storeName).put({key:e,value:t,timestamp:Date.now()});i.onsuccess=function(){s()},i.onerror=function(e){a(e.target.error)}})).catch(a)}))}clear(){const e=this;return new Promise((function(t,r){if(!e.db)return console.error("Database not initialized"),void t();const s=e.db.transaction([e.storeName],"readwrite").objectStore(e.storeName).clear();s.onsuccess=function(){t()},s.onerror=function(e){r(e.target.error)}}))}checkSize(){const e=this;return new Promise((function(t,r){const s=e.db.transaction([e.storeName],"readonly").objectStore(e.storeName).count();s.onsuccess=function(){s.result>=e.maxSize?e.evictOldest().then(t).catch(r):t()},s.onerror=function(e){r(e.target.error)}}))}evictOldest(){const e=this;return new Promise((function(t,r){const s=e.db.transaction([e.storeName],"readwrite").objectStore(e.storeName).index("by_timestamp").openCursor(null,"next");s.onsuccess=function(e){const r=e.target.result;r?r.delete().onsuccess=function(){t()}:t()},s.onerror=function(e){r(e.target.error)}}))}updateTimestamp(e){const t=this;return new Promise((function(r,s){const a=t.db.transaction([t.storeName],"readwrite").objectStore(t.storeName),i=a.get(e);i.onsuccess=function(e){const t=e.target.result;t?(t.timestamp=Date.now(),a.put(t).onsuccess=function(){r()}):r()},i.onerror=function(e){s(e.target.error)}}))}}const stores_WebStore=WebStore;class Memoize{constructor(e,t){this.hamsters=e,this.store=this.hamsters.habitat.node?new stores_NodeStore(t):new stores_WebStore("hamstersjs","cacheStore",t)}memoize(e){const t=this;return function(r){const s=t.generateTaskKey(r);return new Promise((function(a,i){t.store.get(s).then((function(n){null!==n?a(n):t.applyFunc(e,r).then((function(e){t.store.set(s,e).then((function(){a(e)})).catch(i)})).catch(i)})).catch(i)}))}}generateTaskKey(e){const t=JSON.stringify({input:e.input});return this.hashCode(t)}hashCode(e){let t,r,s=0;if(0===e.length)return s;for(t=0;t<e.length;t++)r=e.charCodeAt(t),s=(s<<5)-s+r,s|=0;return s.toString()}applyFunc(e,t){return new Promise(((r,s)=>{try{r(e.apply(null,t))}catch(e){s(e)}}))}}const memoize=Memoize;class RustyHamsters{constructor(){this.version="1.0.0",this.run=this.hamstersRun.bind(this),this.promise=this.hamstersPromise.bind(this),this.init=this.initializeLibrary.bind(this),this.data={},this.pool={},this.scaffold={},this.habitat={},this.memoize={}}initializeLibrary(e){this.data=new data(this),this.pool=new pool(this),this.scaffold={legacy:new legacy.A,regular:new regular.A,shared:new shared.A},this.habitat=new habitat(this),this.memoize=new memoize(this,100),this.processStartOptions(e),this.habitat.legacy||!0!==this.habitat.persistence||this.pool.spawnHamsters(this.habitat.maxThreads),this.maxThreads=this.habitat.maxThreads,console.info(`RustyHamsters.js ${this.version} initialized using up to ${this.habitat.maxThreads} threads`)}processStartOptions(e){if(void 0!==e)for(const t of Object.keys(e))this.habitat.keys.includes(t.toLowerCase())?this.habitat[t]=e[t]:this[t]=e[t];let t=void 0!==e&&void 0!==e.legacy;t&&(t=e.legacy),"function"!=typeof this.habitat.Worker||t||(this.habitat.legacy=this.habitat.isIE)}scheduleTask(e,t,r){return e.input.memoize?this.memoize.memoize((()=>this.pool.scheduleTask(e)))(e).then(t).catch(r):this.pool.scheduleTask(e).then(t).catch(r)}hamstersPromise(e,t){return new Promise(((r,s)=>{this.scheduleTask(new task(this,e,t),r,s)}))}hamstersRun(e,t,r,s){this.scheduleTask(new task(this,e,t),r,s)}}const rustyHamsters=new RustyHamsters;return __webpack_exports__=__webpack_exports__.default,__webpack_exports__})()));
//# sourceMappingURL=rustyHamsters.web.min.js.map